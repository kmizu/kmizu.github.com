<!doctype html>
<html lang="ja">

	<head>
		<meta charset="utf-8">

		<title>PEGのパラメタ付き拡張Macro PEGの提案</title>

		<meta name="description" content="PEGのパラメタ付き拡張Macro PEGの提案">
		<meta name="author" content="Kota Mizushima">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">
<style type="text/css">
  .reveal h1,
  .reveal h2,
  .reveal h3,
  .reveal h4,
  .reveal h5,
  .reveal h6 {
    text-transform: none;
  }
</style>


		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section data-markdown data-separator="^\n---$"><script type="text/template">
          ## PEGのパラメタ付き拡張Macro PEGの提案
          ## 水島 宏太（株式会社ドワンゴ）

---

          ## この発表について
          * PEGについて
          * Macro PEGを提案
            * PEGの規則が引数を取れるように拡張したもの
          * Macro PEGは文法の再利用性を向上させる
            * 引数付き規則
          * Macro PEGは様々なパターンを簡潔に表現できる
            * 順列言語
              * プログラミング言語のアクセス修飾子等
            * 回文（Pure PEGでは表現できなさそう）
          * Macro PEGはパーザコンビネータと綺麗に対応が付く
          * Macro PEGでは表現困難なパターン

---

          ## PEG（Parsing Expression Grammar）
          * Bryan Fordによって2004年に提案された形式文法
          * Yet another formal language by Bryan Ford(2004)
          * 源流はBirmanのTDPL（1970s）

---

          ## PEGの特徴
          * 分析的形式文法
            * <-> 生成文法
          * Packrat Parsingで線形時間で解析可能
          * 任意の決定的文脈自由言語を解析可能
          * 一部の文脈依存言語を解析可能
            * a^n b^n c^n（n≧1）
          * PEL ⊃CFL かどうかはOpen Problem
           * PEL: Parsing Expression Language
           * CFL: Context Free Language

---

          ## PEGの基本（１）
          * 空文字列: ε or ""
          * 文字列リテラル: " "
          * 文字クラス: [ ]
          * 非終端記号: N

---

          ## PEGの基本（２）
          * 連接: e1 e2
          * 優先度付き選択: e1 / e2
          * 0回以上の繰り返し: e*
          * 1回以上の繰り返し: e+
          * 0回または1回の出現: e?
          * And-predicate: &e
          * Not-predicate: !e

---
         ## PEGによる四則演算言語の表現

```
E <- A ("+" A / "-" A)*
A <- P ("*" P / "/" P)*
P <- "(" E ")" / [1-9]+
```

---

          ## PEGによる文脈依存言語(a^n b^n c^n)の表現
          * CFGでは表現不可
          * ¬(CFL ⊃PEL)

```
S ← &(A !b) a+ B !.
A ← a A? b
B ← b B? c
```

---

          ## PEGで回文を表現できるか
          * 直観的な定義ではうまく表現できない

```
S <- "a" S "a" / "b" S "b" / ""
```
          * 実際に表現不可能かは不明

---

          ## PEGの問題点(1) - 文法の再利用性 -

```
Spacing <- " " / "\t" / "\r" / "\n"
Expression <- Primary (
"+" Spacing Primary
"-" Spacing Primary
)*
Primary <- "(" Spacing Expression ")" Spacing /
NumberLiteral Spacing /
StringLiteral Spacing
NumberLiteral <- "0" | [1-9][0-9]*
StringLiteral <- "\""
("#{" Expression "}" / !"\"" .)*
"\""
```

---

          ## Macro PEG
          * 今回提案する手法
          * マクロのような引数を取る規則を追加する
          * Macro Grammarの影響
            * [Grammars with macro-like productions](http://dl.acm.org/citation.cfm?id=1440085)
          * 引数付き規則の評価戦略: 名前呼び出し

```
Double(e) <- e e;
S <- Double("A"); //matched to "AA"
```

---

          ## Macro PEGの基本的な性質
          * 言語クラスをMPELと表現する
          * L(G1) ∪L(G2) ∈MPEL
          * L(G1) ∩L(G2) ∈MPEL
          * L(not(G1)) ∈ MMEPL
          * 証明はFord04と同様

---

          ## Macro PEGによる回文の表現
          * Macro PEGでは簡単に表現できる
            * 引数にこれまでマッチした文字列を逆順で積み込む
          * (Macro PEL) ⊃CFL?

```
S <- P("") !.
P(r) <- "a" P("a" r)) / "b" P("b" r) / r
```

---

          ## 'sequence without repetition' language
          * `{"abc", "acb", "bca", "bac", "cab", "cba"}`
          * modifiers in some programmign languages
          * "public static final", "public final static", ...
          * grammar size in PEG: O(n!)
            * n is kind of modifiers probably

---

          ## Macro PEGによる順列言語の表現
          * `AlreadyLooked`が表のような役目を果たす

```
S = Modifiers(!"", "") !.;
Modifiers(AlreadyLooked) = (!AlreadyLooked) (
    Token("public") Modifiers(AlreadyLooked / "public")
  / Token("protected") Modifiers(AlreadyLooked / "protected")
  / Token("private") Modifiers(AlreadyLooked / "private")
  / Token("static") Modifiers(AlreadyLooked / "static")
  / Token("final") Modifiers(AlreadyLooked / "final")
  / ""
);
Token(t) = t Spacing;
Spacing = " "*;
```

---

          ## Macro PEGによる[加算の表現](https://github.com/kmizu/macro_peg/blob/fd4525f86d30b3dd6573f33deebdc5f00a08c9a3/src/main/scala/com/github/kmizu/macro_peg/MacroPEGRunner.scala#L19-L47)
          * `1`の出現数nを整数nとみなす
            * e.g. 1 = 1, 11 = 2, 111 = 3

```
S = (Plus0("")) !.;
Plus0(Left) = Plus1(Left, "") / &(Left "1") Plus0(Left "1");

Plus1(Left, Right)
  = &(Left "+" Right "=") Plus2(Left, Right)
  / &(Left "+" Right "1") Plus1(Left, Right "1");

Plus2(Left, Right)
  = Left "+" Right "=" Left Right;

"1+1=11", "111+11=11111", "111+1=11111" // should match
"111*11=111111", "11*111=111111", "1*111=1" // should match
```

---

          ## Macro PEGによる[減算の表現](https://github.com/kmizu/macro_peg/blob/fd4525f86d30b3dd6573f33deebdc5f00a08c9a3/src/main/scala/com/github/kmizu/macro_peg/MacroPEGRunner.scala#L66-L82)

```
S = ReadRight("") !.;
ReadRight(Right)
  = &("1"* "-" Right "1") ReadRight(Right "1")
  / &("1"* "-" Right "=") ReadDiff(Right, "");

ReadDiff(Right, Diff)
  = &("1"* "-" Right "=" Diff "1") ReadDiff(Right, Diff "1")
  / &("1"* "-" Right "=" Diff !.) Check(Right, Diff);

Check(Right, Diff)
  = Right Diff "-" Right "=" Diff;

11-1=1", "1-1=", "111-11=1", // should match
111-1=1",  "111-1=111", "1-11=" // should not match
```

---

          ## Macro PEGで[指数の計算](https://github.com/kmizu/macro_peg/blob/fd4525f86d30b3dd6573f33deebdc5f00a08c9a3/src/main/scala/com/github/kmizu/macro_peg/MacroPEGRunner.scala#L88-L125)

```
S = ReadLeft("", "") !.;

ReadLeft(LeftAsOnes, LeftAsDots)
  = &(LeftAsOnes "1") ReadLeft(LeftAsOnes "1", LeftAsDots .)
  / &(LeftAsOnes "^") ComputePadding(LeftAsOnes, LeftAsDots, "");

ComputePadding(LeftAsOnes, LeftAsDots, Padding)
  = &(Padding LeftAsDots .) ComputePadding(LeftAsOnes, LeftAsDots, Padding .)
  / &(Padding LeftAsDots !.) ReadRight(LeftAsOnes, Padding, "", "1");

ReadRight(Left, Padding, Right, Exp)
  = &(Left "^" Right "1") Multiply(Left, Padding, Right "1", Exp, "", "")
  / &(Left "^" Right "=") Check(Left, Right, Exp);

Multiply(Left, Padding, Right, OldExp, Exp, I)
  = &(Padding I .) Multiply(Left, Padding, Right, OldExp, Exp OldExp, I .)
  / &(Padding I !.) ReadRight(Left, Padding, Right, Exp);

Check(Left, Right, Exp)
  = Left "^" Right "=" Exp;

"11^111=11111111", "11^=1", "1^11=1", "^11=", // should match
"11^111=1111111",  "11^111=111111111" // should not match
```

---

          ## Macro PEGとパーザコンビネータの[対応関係](https://github.com/kmizu/macro_peg/blob/master/src/main/scala/com/github/kmizu/macro_peg/combinator/MacroParsers.scala)

---

          ## Macro PEGが表現できない文法
          * 変数宣言に依存する構文
            * 後方参照のような拡張によって解決可能

```
int x;
x * x; // OK
```

```
x * x; // parse error
```

---

          ## 後方参照付きMacro PEG
          * [`EvalCC` コンビネータ](https://github.com/kmizu/macro_peg/blob/fd4525f86d30b3dd6573f33deebdc5f00a08c9a3/src/main/scala/com/github/kmizu/macro_peg/combinator/MacroParsers.scala#L52-L61)として実装

---

          ## 後方参照付きMacro PEGが表現できるもの(1)
          * [変数宣言に依存する構文](https://github.com/kmizu/macro_peg/blob/fd4525f86d30b3dd6573f33deebdc5f00a08c9a3/src/test/scala/com/github/kmizu/macro_peg/MacroParsersSpec.scala#L73-L91)

```
object L {
  lazy val Spacing: P[Any] = ("\r" | "\t" | " " | "\r" | "\n").*
  def OPEN: P[Any] = "(" ~ Spacing
  def CLOSE: P[Any] = ")" ~ Spacing
  def EQ: P[Any] = "=" ~ Spacing
  def SEMI_COLON: P[Any] = string(";") ~ Spacing
  def VAL: P[Any] = "val" ~ Spacing
  lazy val S: P[Any] = Statements(!"") ~ !any
  def Statements(table: P[Any]): P[Any] = VAL ~ Identifier.evalCC{i => EQ ~ Expression(table) ~ SEMI_COLON ~ refer(Statements(table | i)).? } / Expression(table) ~ SEMI_COLON ~ refer(Statements(table)).?
  def Expression(table: P[Any]): P[Any] = refer(Primary(table)) ~ (range(Seq('+','-','*','/')) ~ Spacing ~ refer(Primary(table))).*
  def Primary(table: P[Any]): P[Any] =  table.and ~ Identifier | IntegerLiteral | (OPEN ~ refer(Expression(table)) ~ CLOSE)
  lazy val Identifier: P[Any] = range('a'to'z','A'to'Z',Seq('_')) ~ range('a'to'z','A'to'Z','0'to'9',Seq('_')).* ~ Spacing
  lazy val IntegerLiteral: P[Any] = range('0'to'9').+ ~ Spacing
}
```

---

          ## 後方参照付きMacro PEGが表現できるもの(2)
          * [min-xml](https://github.com/kmizu/macro_peg/blob/fd4525f86d30b3dd6573f33deebdc5f00a08c9a3/src/test/scala/com/github/kmizu/macro_peg/MacroParsersSpec.scala#L60-L72)

```scala
object MinXML {
  lazy val I: P[Any] = range('a'to'z','A'to'Z', Seq('_')) ~ range('a'to'z','A'to'Z',Seq('_'),'0'to'9').*
  lazy val S: P[Any] = "<" ~ I.evalCC {tag =>
    ">" ~ S.* ~ "</" ~ tag ~ ">"
  }
}
```

---
          # 関連研究
          * Matsumura, T. and Kuramitsu, K.(2016): 
            * PEGに対して実用的なプログラミング言語を扱うための拡張を提案
          * Warth, A., Douglass, J. R. and Millstein, T(2008):
            * PEGに対して左再帰拡張を提案
            * Packrat Parsingのアルゴリズムを利用
            * 既に不具合が発見されている
              * 白田，木山，芦原(2011)
            * 左再帰をどこまで扱えるか不明

---

          # まとめ
          * Macro PEGを提案
            * PEGに引数付き規則を追加したもの

          * 和集合・積集合・補集合に関して閉じている
          * Macro PEGとパーザコンビネータは綺麗に対応する
          * Macro PEGの表現力は不明
			  </script></section>
      </div>
		</div>
    

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
