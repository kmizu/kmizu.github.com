<!doctype html>
<html lang="ja">

	<head>
		<meta charset="utf-8">

    <title>はじめに</title>

		<meta name="description" content="一意性と借用">
		<meta name="author" content="水島宏太">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">
<style type='text/css'>     
  .reveal h1,               
  .reveal h2,               
  .reveal h3,               
  .reveal h4,               
  .reveal h5,               
  .reveal h6 {              
    text-transform: none;   
  }                         
</style>                    

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
<div class='slides'>
<section data-markdown data-separator='^\n---$'><script type='text/template'>

## 一意性と借用
## 構文解析友の会 水島宏太

---

## 自己紹介

- Twitter ID: [@kmizu](https://twitter.com/kmizu)
- GitHub: [kmizu](https://github.com/kmizu)
- Love: Nemerle/Rust/Standard ML/Scala/...
  - 言語オタク
- 自分のプログラミング言語も作ってます
  - [Klassic](https://github.com/klassic/klassic)
  - [Onion](https://github.com/onion-lang/onion)
- Japan Scala Association代表理事

---

## 紹介する論文

### Capabilities for Uniqueness and Borrowing
### Philip Haller, Martin Odersky
### ECOOP2010

- http://lampwww.epfl.ch/~phaller/capabilities.html

---

## 概要

- 動機
  - 並行プログラミングにおけるメッセージ送信
  - Mutable Objectがあると安全ではない
  - 既存手法は制限が強い

- 貢献
  - 参照の一意性を保証するための新しい手法を提案
  - 型システムの健全性を照明

- 実装
  - Scalaのコンパイラプラグイン

---

## 問題

- Actorライブラリを使ったプログラミング
  - Actor間でのメッセージ送信

- mutableなオブジェクトを送信：
  - race conditionが発生する可能性
  - Actor間でのオブジェクトのaliasing

- immutableなオブジェクトを送信：
  - 安全

---

## 考察

- mutableなオブジェクトを送信してはいけない
  - 本当に？

- Actor間でオブジェクトが **共有** されなければいい

```scala
val bufer = Buffer[Int]()
buffer ++= (1, 2, 3, 4)
anActor ! buffer
// don"t touch to buffer
```

- オブジェクトが **共有** されないことを保証したい
  - 参照の **一意性**

---

## 一意型について

- 代表選手：Clean

- 別名付けを **観測できなければ** 不変と同じ
  - オブジェクトを破壊的に更新しても良い

- 擬似コードで表現：

```scala
val oldArray: *Array[Int] = Array(1, 2, 3)
val newArray: oldArray.updated(0, 4)
// println(oldArray(0)) compile error
```

---

## 単純な一意型の問題

- 送信できるオブジェクトの形式が制限される

- OK: 木構造

- NG: グラフ構造
  - オブジェクトの参照関係はグラフ構造を持つ

- 制限を緩めたい

---

## 先行研究

![先行研究](related-works.png)

---

### External Uniqueness
### Separate Uniqueness

![一意性](uniqueness-figure.png)

---

## Capability

- 本論文における中心的な概念

- `p▷T` : 型 `T` は `q` によって守られる

- Capabilityの二つの役割
  - ヒープ上のdisjointな領域の表現
  - 領域内におけるオブジェクトへのアクセス権

- 一意性を細かく制御可能

---

## 注釈

- `@unique`
  - 参照が一意な変数で、capabilityを持つ
- `@transient`
  - capabilityを消費しない
- `@peer(this)`
  - `this` と同じヒープ領域を指す

---

## LogList（１−１）

```scala
class LogList {
  var elem: LogFile = null
  var next: LogList = this
  @transient def add(f: LogFile @peer(this)) = {
    if(isEmpty) { elem = f; next = new LogList }
    else next.add(f)
  }
}
```

---

## LogList（１−２）

```scala
def runTests(kind: String, tests: List[Files]): Unit = {
  var succ, fail = 0
  val logs: LogList @unique = new LogList
  for(t <- tests) {
    val log: LogFile @unique = newLogFile(test)
    run tests ...
    logs.add(log)
  }
  report(succ, fail, logs)
}

def report(succ: Int, fail: Int, logs: LogList @unique): Unit = {
  master ! new Results(succ, fail, logs)
}
```

---

## LogList（１−３）

```scala
def runTests(kind: String, tests: List[Files]): Unit = {
  var succ, fail = 0
  val logs: LogList @unique = new LogList
  for(t <- tests) {
    val log: LogFile @unique = newLogFile(test)
    run tests ...
    logs.add(capture(log, logs))
  }
  report(succ, fail, logs)
}

def report(succ: Int, fail: Int, logs: LogList @unique): Unit = {
  master ! new Results(succ, fail, logs)
}
```

---

## 感想

- Capabilityベースの一意性は興味深い

- 注釈がいっぱいでしんどい
  - もうちょっと推論できないのか

- captureがテキトー過ぎる

- コンパイラプラグインなせいで現行Scalaの実装に対応できない
  - 今ならマクロとか使うべきところ？

</script></section>

      </div>
		</div>
    

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
