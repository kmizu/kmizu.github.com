<!doctype html>
<html lang="ja">

	<head>
		<meta charset="utf-8">

    <title>自作言語Onionの実装</title>

		<meta name="description" content="Haskell VS. Scala">
		<meta name="author" content="Kota Mizushima">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">
<style type='text/css'>     
  .reveal h1,               
  .reveal h2,               
  .reveal h3,               
  .reveal h4,               
  .reveal h5,               
  .reveal h6 {              
    text-transform: none;   
  }                         
</style>                    

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class='slides'>
<section data-markdown data-separator='^\n---$'><script type='text/template'>

## 自作言語Onionの実装
## 言語実装勉強会（2018/11/17）
## 構文解析友の会 水島宏太

---

### 自己紹介

- Twitter: [@kmizu](https://twitter.com/kmizu)
- GitHub: [kmizu](https://github.com/kmizu)
- 好きな言語: Scala,Nemerle,Racket, etc.
- 構文解析（生成系）が大好き
- プログラミング言語作りが趣味
  - Onion <- Suspended
  - Klassic <- Active
- Japan Scala Association代表理事

---

### Onionの概要

- 自作のプログラミング言語とその処理系（on JVM）
- 静的型付きオブジェクト指向言語
- JVMのクラスファイルを出力する
- from 2005（学部3年）〜
  - 数年前にJavaからScalaに移行
- 最近はほぼ更新停止
  - 気が向いたら手を加えたい

---

### 脱線

- JVM言語っていい方はちょっと変
- 言語（仕様）と処理系（実装）の話が混ざってる

---

### Onionの特徴

- 当時としては、軽量な静的型付け言語
- スクリプト言語的（古い）
  - トップレベル文
  - 代入による変数宣言
    - Rubyに影響された
  - 自動ダウンキャスト
    - 数年前に削除
  - クラス移譲

---

### Hello, Onion

- この一行で正しいOnionプログラム
- 仕様としてトップレベルがある

```scala
System::out.println("Hello, World!");
```

---

### 代入による変数宣言

- 未宣言の変数への代入が宣言となる
- 再代入は普通の代入
- 型は初期化式の型になる
  - いわゆるローカル変数型推論
- 明示的な変数宣言もできる

---

### 代入による変数宣言

```scala
frame = new JFrame(“Frame”);//frameを宣言
pane = frame.getContentPane(); // paneを宣言
pane.setLayout(new FlowLayout);
for i = 0; i < 9; i = i + 1 {// iを宣言
  pane.add(new JButton("Button" + i));
}
frame.pack;
frame.setVisible(true);
```

---

### 自動ダウンキャスト

- スーパータイプの式をサブタイプに代入時にキャストを自動挿入
- 非互換な型は型エラー
- イケてないので最終的に消した
  - Gradual Typing的なものに進化できたかも

---

### 自動ダウンキャスト

```scala
xs = ["A", "B", "C"];
foreach x in xs {
  s: String = s; // 自動ダウンキャスト
  System::out.println(s);
}
```

---

### クラス委譲

- Kotlinとかにある
- インタフェースの実装をフィールドに委譲

---

### クラス委譲

```scala
clas AList <: List {
  forward @xs: List;
public:
  new { @xs = []; }
}

ys = new AList;
// メソッドが自動生成されている
ys.add("Foo");
ys.add("Bar");
```

---

### 無名関数

- 今ではすっかりお馴染みの機能
- いわゆるクロージャ

---

### 無名関数

```scala
add = #(a: Object, b: Object) { 
  return a$String + b$String; 
}
System::out.println(add.call("A", "B")); // AB
```

---

### Onion処理系の概要

- 約7000行のScalaプログラム
- JavaCCによる構文定義
  - 約900行
- Apache BCELでクラスファイル生成
  - 今書き直すならASMだろう

---

### Onion処理系の特徴

- 独自のランタイムを持たない
  - javaコマンドで（ランタイムjarなしに）動く
  - 開発当時は配布サイズを重視したため
- クラスファイルを吐く
  - 割とjavacに近いレベルの素朴さ
- Scalaで書かれている

---

### Onion処理系の処理の流れ

1. 字句解析（JavaCCから生成）
2. 構文解析（JavaCCから生成）
3. クラス名表の作成
4. 継承関係とメンバの型の解決
5. 委譲メソッドの生成
6. 型チェック
7. 中間表現への変換
8. 中間表現からコード生成（with BCEL）

---

### 当時の苦労ポイント

今ならなんてことはない

- トップレベルの実装
- バイトコード生成
- 無名関数（クロージャ）実装

---

### トップレベルの実装 - Scala, Kotlin

- トップレベルに評価可能な式（文）は書けない
  - scalac/kotlincコマンド
- 特別なコマンドで実行した場合、外側をクラスでラップしてコンパイル
  - scala/kotlinコマンド

---

### トップレベルの実装 - Onion

- トップレベル文が存在
  - そのまま実行可能（onionコマンド）
  - 明示的なコンパイルも可能（onioncコマンド）
- トップレベルに宣言（クラス/インタフェース）も書ける
- 両者を混ぜることもできる

---

### トップレベルの実装 - Onion

- 宣言と文の混在をどう処理すべきか

```scala
class A {
}
println(new A);
println(new B);
class B {
}
```

---

### トップレベルの実装 - Onion

トップレベル文

1. エントリポイントを生成
  - クラス： ファイル名-拡張子+Main
    - e.g. `A.on` --> `AMain`
  - メソッド： `start(args: String[])`
2. トップレベル要素のリストをたどる
3. トップレベル文のリストを作成
4. エントリポイントにトップレベル文のリストを埋め込む
5. mainメソッドを生成
  - トップレベル用クラスのインスタンスを生成
  - startメソッドの呼び出し

---

### トップレベルの実装 - Onion

クラスとインタフェース

普通に処理

- 相互依存関係解決
- 循環継承検出
- , etc.

---

### トップレベルの実装 - Onion

```scala
// Foo.on
class A {}
println(new A);
println(new B);
class B {}
```

↓

```scala
class FooMain {
public:
  static main(args: String[]) {
    (new FooMain).start(args);
  }
  start(args: String) {
    println(new A);
    println(new B);
  }
}
class A {}
class B {}
```

---

</script></section>

      </div>
		</div>
    

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
